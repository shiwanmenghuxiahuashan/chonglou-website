# 数据层架构

**AI 指令**：请根据以下分步指令，构建一个功能完备、可扩展且与**任何前端框架无关**的通用数据层。所有代码应使用 TypeScript 编写，并严格遵循模块化、高内聚、低耦合的设计原则。

## **模块一：核心 HTTP 客户端封装**

**架构目标**：构建一个独立的、与底层库解耦的 HTTP 客户端。

- **任务**：封装一个名为 `httpClient.ts` 的模块。
- **实现细节**：
  - 该模块应是**纯 JavaScript/TypeScript**，不包含任何与 Vue、React 等框架相关的代码。
  - 提供 `get`, `post`, `put`, `delete`, `patch` 等符合 RESTful 风格的原子化方法。
  - 所有请求方法都应返回**原生 `Promise`**，并提供泛型支持以确保类型安全。
  - 在模块内部定义并使用一套自定义的标准请求配置（如 `timeout`, `baseURL`, `headers`），**禁止**在模块外部直接访问或依赖 `axios` 原生配置。

## **模块二：认证与 Token 管理**

**架构目标**：建立一个独立的 Token 管理服务，其逻辑不依赖于任何框架的状态管理。

- **任务**：创建一个名为 `tokenService.ts` 的模块。
- **实现细节**：
  - `tokenService` 应提供 `getToken()`, `setToken(token: string)`, `removeToken()` 等方法，用于对 Token 的增删改查。Token 应安全地存储在 `localStorage` 或 `sessionStorage` 中。
  - 在 `httpClient.ts` 的**请求拦截器**中，自动从 `tokenService` 中获取 Token 并将其添加到请求头的 `Authorization` 字段。
  - 实现**Token 自动刷新机制**：当响应状态码为 401（未授权）时，请求拦截器应捕获此错误。它需要自动发起一个刷新 Token 的请求，成功后用新的 Token 重试之前的失败请求。

## **模块三：请求拦截与插件系统**

**架构目标**：构建一个可插拔的、链式调用的请求与响应拦截器系统，以支持多种增强功能。

- **任务**：设计并实现一个基于**拦截器**的**插件系统**。
- **实现细节**：
  - **缓存插件**：基于 `web-memcache`（https://www.npmjs.com/package/web-memcache） 库，设计一个缓存插件。该插件应在请求拦截器中检查缓存。如果请求在缓存中且未过期，则直接返回缓存数据，**阻止**实际的网络请求。
  - **错误处理**：在响应拦截器中，统一处理所有非 200 状态码的响应。对外暴露一个 `handleError` 函数，用于集中管理错误提示（例如，在 Vue 环境中调用 `ElMessage`，或在 React 环境中调用 `toast` 库，但这部分调用**不应**直接写在 `httpClient` 模块内）。
  - **请求重试**：实现一个请求重试插件。当请求失败时，该插件应自动按照预设的次数和时间间隔进行重试。
  - **请求取消**：使用 `AbortController` 实现请求取消功能。对外暴露一个 `cancelRequest(id: string)` 方法，支持根据请求 ID 取消特定的正在进行的请求。

## **模块四：性能与竞态管理**

**架构目标**：通过节流、防抖和竞态守卫，优化请求性能并避免数据不一致。

- **任务**：在 `httpClient.ts` 中集成请求管理功能。
- **实现细节**：
  - **竞态守卫**：实现一个**竞态守卫**（Race Guard）。当同一 URL 的请求正在进行时，新的同 URL 请求不应再次发起，而应等待前一个请求完成并返回其结果。
  - **请求节流与防抖**：提供一个可选的参数，允许对某个特定的 `httpClient` 方法应用**请求节流**（Throttling）或**请求防抖**（Debouncing）逻辑，以控制高频请求。
