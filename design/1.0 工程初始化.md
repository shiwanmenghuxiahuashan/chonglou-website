# 工程初始化

## **指令序列：前端架构与工程化基石构建**

### **第一阶段：工程化架构基石**

**总目标：** 专注于构建一个具备高可维护性和高扩展性的基础架构，为所有业务开发打下坚实基础。

#### **任务 1.1：项目脚手架与依赖初始化**

- **指令：**
  1. 使用 `pnpm create vite` 命令，创建一个基于 Vue 3 + TypeScript 的新项目，并命名为 `my-personal-website`。
  2. 在项目中安装核心依赖：`vue-router`, `pinia`, `element-plus`。
  3. 请生成**详细的项目目录结构树**，遵循特性驱动模式，包含 `src/components`, `src/pages`, `src/services`, `src/stores`, `src/utils` 等关键目录。
- **产出：**
  - `pnpm install` 命令输出。
  - 一个完整的 `tree` 命令生成的项目目录结构图。

#### **任务 1.2：代码规范与自动化工作流**

- **指令：**
  1. 请列出并安装所有用于代码规范的 `pnpm` 依赖，包括 `eslint`, `prettier`, `stylelint`, `husky`, `lint-staged` 等及其 Vue/TypeScript 相关插件。
  2. 为 `ESLint` 和 `Prettier` 生成 `.eslintrc.cjs` 和 `.prettierrc` 配置文件。配置中需集成 `@vue/eslint-config-typescript` 和 `@element-plus/eslint-config`，并确保 `TypeScript` 支持。
  3. 为 `Stylelint` 生成 `.stylelintrc` 配置文件。
  4. 配置 `package.json` 中的 `scripts`，添加 `lint:js`, `lint:css` 命令。
  5. 配置 `husky` 和 `lint-staged`，使其在 `pre-commit` 钩子中自动运行 `eslint` 和 `stylelint` 检查。
- **产出：**
  - 包含所有依赖的 `pnpm install` 命令。
  - 所有规范化工具的**完整配置文件**代码块。
  - `package.json` 中 `scripts` 和 `husky` 相关配置代码。

#### **任务 1.3：全局样式体系与主题化架构**

- **指令：**
  1. 在 `src` 目录下创建 `styles` 目录，并在其中创建 `_variables.scss`, `_mixins.scss` 和 `_normalize.scss` 文件。
  2. 在 `_variables.scss` 中，使用 `Sass` 变量和 `CSS Variables` 定义一套基础的颜色和字体变量，并注释说明其用途。
  3. 在 `main.ts` 中，全局引入 `_normalize.scss`。
  4. 生成一个示例组件（例如 `Button.vue`），在 `<style>` 块中，使用 `@use` 语法导入 `_variables.scss`，并使用命名空间访问变量，以演示新版Sass用法。
- **产出：**
  - `src/styles` 目录下的所有 `.scss` 文件内容。
  - `main.ts` 文件中全局引入样式的代码。
  - 一个完整的 `Button.vue` 组件代码。

#### **任务 1.4：路由与状态管理基石**

- **指令：**
  1. 在 `src/router` 目录下，创建 `index.ts` 和 `modules` 目录。
  2. 在 `modules` 目录下，创建 `article.ts` 和 `home.ts` 两个模块化路由文件，并导出路由数组。
  3. 在 `src/stores` 目录下，创建 `auth.ts` 和 `settings.ts` 两个 Pinia Store 模块，分别管理用户的登录状态和网站设置（例如主题模式）。
  4. 生成一个基础的路由守卫（例如在 `router/index.ts` 中），使用 Pinia Store 中的 `auth` 模块来判断是否登录。
- **产出：**
  - 所有路由文件的代码（`index.ts`，`modules/article.ts`, `modules/home.ts`）。
  - 所有 Pinia Store 文件的代码（`auth.ts`, `settings.ts`）。
  - 包含路由守卫的 `main.ts` 或 `router/index.ts` 代码。

---

### **第二阶段：核心业务骨架与组件化**

**总目标：** 在第一阶段的架构基础上，开始填充具体的业务内容，并强调组件化、可复用和高性能。

#### **任务 2.1：通用组件与布局组件库**

- **指令：**
  1. 在 `src/components/common` 目录下，生成 `Empty.vue` 和 `Icon.vue` 两个通用组件的骨架代码。`Icon.vue` 组件应通过 `props` 接收图标名称。
  2. 在 `src/components/layouts` 目录下，创建 `MainLayout.vue` 组件。该组件应包含 `Header`, `Sidebar`, `RouterView` 和 `Footer` 的占位符 `<slot>` 或组件引用。
- **产出：**
  - `Empty.vue` 和 `Icon.vue` 的完整代码。
  - `MainLayout.vue` 的完整代码。

#### **任务 2.2：模块化业务页面与数据服务**

- **指令：**
  1. 安装 `axios` 依赖。
  2. 在 `src/services` 目录下，生成 `article.service.ts` 文件。该文件应包含 `getArticle` 和 `getArticleDetail` 两个异步函数，并使用 `axios` 模拟API请求（返回 Mock 数据）。
  3. 在 `src/stores` 目录下，生成 `article.ts` Pinia Store 模块。该模块应包含一个异步 action，用于调用 `article.service` 中的函数并更新状态。
- **产出：**
  - `article.service.ts` 的完整代码。
  - `article.ts` Store 模块的完整代码。

#### **任务 2.3：性能与体验优化集成**

- **指令：**
  1. 请安装 `vite-plugin-pwa`。
  2. 在 `vite.config.ts` 文件中，添加 `VitePWA` 插件的配置，确保其能生成 `manifest.json` 和 `service-worker.js` 文件。
  3. 生成一个名为 `useWebWorker.ts` 的 Vue Composition API Hook，用于封装 Web Worker 逻辑。该 Hook 应该能接收一个函数作为参数，并在 Worker 中执行。
- **产出：**
  - `vite.config.ts` 文件中新增的配置代码。
  - `src/utils` 目录下的 `useWebWorker.ts` 文件内容。
